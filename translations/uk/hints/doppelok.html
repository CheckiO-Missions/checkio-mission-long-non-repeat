<body data-author="Doppelok">
<div class="question-answer">
    <div class="question">
        Я не знаю, як почати вирішувати цю місію
    </div>
    <div class="answer">
        <p>Суть місії полягає у тому, що вам потрібно пройти по рядку (стільки разів, скільки потрібно) і знайти всі можливі комбінації унікальних символів. Вони можуть починатися навіть з середини рядка, або, наприклад, у рядку "trgrhsoij" першою комбінацією буде "trg", тому що після "g" йде ще одна "r", але якщо ми відкинемо першу "r", то отримаємо набагато більшу комбінацію. grhsoij".</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Мені потрібна допомога, щоб продовжити місію
    </div>
    <div class="answer">
        <p>Вам буде корисно прочитати деяку інформацію про:
       <a target="_blank" href='https://docs.python.org/3/tutorial/datastructures.html'>list.append()</a>
        (<a target="_blank" href='https://www.w3schools.com/python/ref_list_append.asp'>example</a>) та
       <a target="_blank" href='https://docs.python.org/3.10/library/functions.html?highlight=max#max'>max()</a>
        (<a target="_blank" href='https://www.w3schools.com/python/ref_func_max.asp'>example</a>).</p>
        
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Потрібна допомога!
    </div>
    <div class="answer">
        <p>Давайте почнемо з розуміння порядку нашого коду. Перше, що ми зробимо, це додамо дві змінні-списки. Перша "result", вона буде зберігати унікальні комбінації символів. Друга "new", вона буде зберігати проміжний результат унікальних комбінацій. Далі ми додамо цикл while, в якому будемо перебирати наш рядок, поки не знайдемо всі унікальні комбінації.</p>
        <pre class="brush: python">
result = []
new = []
while line:
    # do something
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Я вже не знаю, що робити далі. Мені потрібна невелика підказка.
    </div>
    <div class="answer">
        <p>Далі ми додамо цикл for, в якому будемо перебирати рядок. Усередині цього циклу потрібно перевірити, чи знайдена вже буква в комбінації чи ні, і виконати відповідні дії.</p>
        <pre class="brush: python">
result = []
new = []
while line:
    for i in line:
        if i not in new:
            # do something
        else:
            # do something
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Нічого не працює. SOS
    </div>
    <div class="answer">
        <p>Гаразд, вам потрібно додати деякі дії до наших умов if. У першій умові перевірка на включення букви в список, якщо такої букви немає - додамо букву в список, якщо така буква вже була, об'єднаємо "новий" список в рядок, додамо його в "результат", знову визначимо "новий" як новий список, і додамо в нього букву, на якій ми зупинилися і підемо далі за аналогією.</p>
        <pre class="brush: python">
result = []
new = []
while line:
    for i in line:
        if i not in new:
            new.append(i)
        else:
            result.append(''.join(new))
            new = []
            new.append(i)
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Допоможіть, будь ласка! Ми майже вирішили цю місію.
    </div>
    <div class="answer">
        <p>Залишилося логічно завершити цикл while. Отже, після того, як ми пройдемося по рядку, ми додамо останній унікальний фрагмент рядка до результату, перевизначимо "new" як новий список і зсунемо наш вхідний рядок вперед на 1 елемент. Це робиться для пошуку нових унікальних фрагментів у рядку. І так до тих пір, поки рядок не стане порожнім.</p>
        <pre class="brush: python">
result = []
new = []
while line:
    for i in line:
        if i not in new:
            new.append(i)
        else:
            result.append(''.join(new))
            new = []
            new.append(i)
    result.append(''.join(new))
    new = []
    line = line[1:]
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Я не хочу здаватися, допоможіть!
    </div>
    <div class="answer">
        <p>Все, що вам потрібно зробити, це обернути код у функціональний вираз і повернути найдовший унікальний рядок зі списку результатів за допомогою функції max(). Ми вказуємо функцію len() як ключовий аргумент і "" як аргумент за замовчуванням, щоб повернути порожній рядок, якщо рядок також порожній.</p>
        <div class="spoiler">
        <pre class="brush: python">
def non_repeat(line: str) -> str:

    result = []
    new = []
    while line:
        for i in line:
            if i not in new:
                new.append(i)
            else:
                result.append(''.join(new))
                new = []
                new.append(i)
        result.append(''.join(new))
        new = []
        line = line[1:]

    return max(result, key= len, default= '')
        </pre>
        </div>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Я хочу бути кращим з кращих програмістів!!! ПОКАЖІТЬ МЕНІ БІЛЬШЕ РІШЕНЬ!!!1!!!11!
    </div>
    <div class="answer">
        <p>Гаразд, гаразд! Ось це настрій!)
        Чудовий приклад використання функції-генератора. Замість return ми використовуємо yield, з його допомогою ми щоразу генеруємо об'єкт-генератор одразу у функції max().</p>
        <div class="spoiler">
        <pre class="brush: python">
def intervals(line):

    last = {}
    start = end = 0
    for i, letter in enumerate(line):
        end += 1
        if letter in last and start <= last[letter]:
            start = last[letter] + 1
        yield line[start:end]
        last[letter] = i

def non_repeat(line):

    return max(intervals(line), key=len, default='')
        </pre>
        </div>
    </div>
</div>
</body>
